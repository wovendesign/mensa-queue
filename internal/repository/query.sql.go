// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const findAllRecipes = `-- name: FindAllRecipes :many
SELECT id, ai_thumbnail_id, price_students, price_employees, price_guests, mensa_provider_id, updated_at, created_at FROM recipes
`

func (q *Queries) FindAllRecipes(ctx context.Context) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, findAllRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.AiThumbnailID,
			&i.PriceStudents,
			&i.PriceEmployees,
			&i.PriceGuests,
			&i.MensaProviderID,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLocale = `-- name: FindLocale :one
SELECT
    locale.id, locale.name, locale.locale,
    locale_rels.path, locale_rels.recipes_id, locale_rels.features_id
FROM locale
    INNER JOIN locale_rels
    ON locale.id = locale_rels.parent_id
WHERE locale.name = $1 LIMIT 1
`

type FindLocaleRow struct {
	ID         int32                `json:"id"`
	Name       string               `json:"name"`
	Locale     NullEnumLocaleLocale `json:"locale"`
	Path       string               `json:"path"`
	RecipesID  pgtype.Int4          `json:"recipes_id"`
	FeaturesID pgtype.Int4          `json:"features_id"`
}

func (q *Queries) FindLocale(ctx context.Context, name string) (FindLocaleRow, error) {
	row := q.db.QueryRow(ctx, findLocale, name)
	var i FindLocaleRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Locale,
		&i.Path,
		&i.RecipesID,
		&i.FeaturesID,
	)
	return i, err
}

const insertRecipe = `-- name: InsertRecipe :one
INSERT INTO recipes (price_students, price_employees, price_guests, mensa_provider_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type InsertRecipeParams struct {
	PriceStudents   pgtype.Numeric `json:"price_students"`
	PriceEmployees  pgtype.Numeric `json:"price_employees"`
	PriceGuests     pgtype.Numeric `json:"price_guests"`
	MensaProviderID int32          `json:"mensa_provider_id"`
}

func (q *Queries) InsertRecipe(ctx context.Context, arg InsertRecipeParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertRecipe,
		arg.PriceStudents,
		arg.PriceEmployees,
		arg.PriceGuests,
		arg.MensaProviderID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertServing = `-- name: InsertServing :execrows
INSERT INTO servings (recipe_id, date, mensa_id)
SELECT $1, $2, $3
    WHERE NOT EXISTS (
    SELECT 1 FROM servings
    WHERE recipe_id = $1 AND date = $2 AND mensa_id = $3
)
`

type InsertServingParams struct {
	RecipeID int32              `json:"recipe_id"`
	Date     pgtype.Timestamptz `json:"date"`
	MensaID  pgtype.Int4        `json:"mensa_id"`
}

func (q *Queries) InsertServing(ctx context.Context, arg InsertServingParams) (int64, error) {
	result, err := q.db.Exec(ctx, insertServing, arg.RecipeID, arg.Date, arg.MensaID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
